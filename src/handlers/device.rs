use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::{IntoResponse as _, Response},
    Json,
};

use crate::{database::DeviceUpdate, error::Result, extractor::auth::RequireAuthentication, Sync};

/// # Update Device Data
///
/// `POST /api/2/devices/(username)/(device_id).json`
///
///   - Requires HTTP authentication
///   - Since 2.0
///
/// The device ID is generated by the client application to identify itself in
/// API requests. The name is used to display a human readable identifier to
/// the user on the web-service. Only the keys that are supplied will be
/// updated.
///
/// ## Parameters
///
///   - **username** - the username for which the devices should be returned
///   - **device_id** - see Devices
///
/// ## Request JSON Object
///
///   - **caption** (string) - The new human readable label for the device
///   - **type** (string) - the type of the device. Possible values: desktop,
///     laptop, mobile, server, other
///
/// ## Example Request
///
/// ```json
/// {
///     "caption": "gPodder on my Laptop",
///     "type": "laptop"
/// }
/// ```
#[tracing::instrument(skip_all, err)]
#[autometrics::autometrics]
pub async fn update(
    RequireAuthentication(session): RequireAuthentication,
    State(sync): State<Sync>,
    Path((username, device_name)): Path<(String, String)>,
    Json(update): Json<DeviceUpdate>,
) -> Result<Response> {
    if session.user.username != username {
        return Ok(StatusCode::UNAUTHORIZED.into_response());
    }

    sync.db
        .update_device(&session.user, &device_name, update)
        .await?;

    Ok(StatusCode::OK.into_response())
}

/// # List Devices
///
/// `GET /api/2/devices/(username).json`
///
///   - Requires HTTP authentication
///   - Since 2.0
///
/// Returns the list of devices that belong to a user. This can be used by the
/// client to let the user select a device from which to retrieve
/// subscriptions, etc..
///
/// ## Parameters
///
///   - **username** - the username for which the devices should be returned
///
/// ## Example Response
///
/// ```json
/// [
///     {
///         "id": "abcdef",
///         "caption": "gPodder on my Laptop",
///         "type": "laptop",
///         "subscriptions": 27
///     },
///     {
///         "id": "09jc23caf",
///         "caption": "",
///         "type": "other",
///         "subscriptions": 30
///     },
///     {
///         "id": "phone-au90f923023.203f9j23f",
///         "caption": "My Phone",
///         "type": "mobile",
///         "subscriptions": 5
///     }
/// ]
/// ```
#[tracing::instrument(skip_all, err)]
#[autometrics::autometrics]
pub async fn list(
    RequireAuthentication(session): RequireAuthentication,
    State(sync): State<Sync>,
    Path(username): Path<String>,
) -> Result<Response> {
    if session.user.username != username {
        return Ok(StatusCode::UNAUTHORIZED.into_response());
    }

    let devices = sync.db.get_devices(&session.user).await?;

    Ok((StatusCode::OK, Json(devices)).into_response())
}

/// # Get Device Updates
///
/// `GET /api/2/updates/(username)/(device_id).json`
///
///   - Requires HTTP authentication
///   - Since 2.3
///
/// The response will have the following form and will contain
///
///  - a list of subscriptions to be added, with URL, title and descriptions
///  - a list of URLs to be unsubscribed
///  - a list of updated episodes
///  - the current timestamp; for retrieving changes since the last query
///
/// If `include_actions` is set to true, each updated episode (with a state other
/// than new) will contain an additional property action which includes the
/// user's latest episode action reported for this episode. The actions have
/// the same format as in Episode Action Types.
///
/// ## Query Parameters
///
///  - **since** - `timestamp` when updates have last been retrieved
///  - **include_actions** (bool) - Default: false, since 2.10
///
/// ## Example Response
///
/// ```json
/// {
///     "add": [
///         {
///             "title": "PaulDotCom Security Weekly",
///             "url": "http://pauldotcom.com/podcast/psw.xml",
///             "description": "PaulDotCom Security Weekly Podcast with Paul, Larry, Mick, Carlos, and special guests!",
///             "subscribers": 93,
///             "logo_url": "http://pauldotcom.com/images/psw-logo-sm.png"
///             "website": "http://pauldotcom.com/",
///             "mygpo_link": "http://gpodder.net/podcast/11194",
///         }
///     ],
///     "remove":  ["<URL3>"],
///     "updates": [
///         {
///             "title": "TWiT 245: No Hitler For You",
///             "url": "http://www.podtrac.com/pts/redirect.mp3/aolradio.podcast.aol.com/twit/twit0245.mp3",
///             "podcast_title": "this WEEK in TECH - MP3 Edition",
///             "podcast_url": "http://leo.am/podcasts/twit",
///             "description": "[...]",
///             "website": "http://www.podtrac.com/pts/redirect.mp3/aolradio.podcast.aol.com/twit/twit0245.mp3",
///             "mygpo_link": "http://gpodder.net/episode/1046492",
///             "released": "2009-12-12T09:00:00",
///             "status": "(new|play|download|delete)"
///         }
///     ],
///    "timestamp": 12347
/// }
/// ```
#[tracing::instrument(skip_all, err)]
#[autometrics::autometrics]
pub async fn updates(
    RequireAuthentication(_session): RequireAuthentication,
    State(_sync): State<Sync>,
    Path((_username, _device_name)): Path<(String, String)>,
) -> Result<Response> {
    return Ok(StatusCode::NOT_FOUND.into_response());
    // if session.user.username != username {
    //     return Ok(StatusCode::UNAUTHORIZED.into_response());
    // }

    // todo!()
}

#[cfg(test)]
mod tests {}
